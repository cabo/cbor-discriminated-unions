



Network Working Group                                          D. Coutts
Internet-Draft                                                          
Intended status: Informational                                M.P. Jones
Expires: 22 July 2021                                                   
                                                         C. Bormann, Ed.
                                                  Universität Bremen TZI
                                                         18 January 2021


                   CBOR Tags for Discriminated Unions
             draft-bormann-cbor-discriminated-unions-latest

Abstract

   The Concise Binary Object Representation (CBOR, RFC 8949) is a data
   format whose design goals include the possibility of extremely small
   code size, fairly small message size, and extensibility without the
   need for version negotiation.

   In programming, there is often a need to define types that are
   composed of enumerated alternatives.  While CBOR has no problem
   representing types that are unions of other types, this may not make
   visible which of the enumerated alternatives was chosen, in
   particular if multiple alternatives overlap in their CBOR
   representations.  In other words, CBOR has no direct support for
   discriminated unions.

   In CBOR, one point of extensibility is the definition of CBOR tags.
   In protocol development, it is possible to register different tags
   for each alternative, but this would be difficult to automate in the
   course of using CBOR for normal program development, it might use up
   registration resources and tag numbers, and would create an unwelcome
   threshold for using CBOR in these activities.

   Instead, the alternatives could simply be numbered by a program
   compiler.  The present document defines tags for such a use in
   discriminated unions, i.e., where there is no intention to register
   application-specific tags for each of the branches in the union.

Note to Readers

   This is an individual submission to the CBOR working group of the
   IETF, https://datatracker.ietf.org/wg/cbor/about/
   (https://datatracker.ietf.org/wg/cbor/about/).  Discussion currently
   takes places on the github repository https://github.com/cabo/cbor-
   discriminated-unions (https://github.com/cabo/cbor-discriminated-
   unions).  If the CBOR WG believes this is a useful document,
   discussion is likely to move to the CBOR WG mailing list and a github
   repository at the CBOR WG github organization, https://github.com/
   cbor-wg (https://github.com/cbor-wg).

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 22 July 2021.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction
   2.  Semantics
   3.  Deterministically Encoded CBOR
   4.  Rationale
   5.  Examples
   6.  IANA Considerations
   7.  Security Considerations
   8.  References
     8.1.  Normative References
     8.2.  Informative References
   Authors' Addresses

1.  Introduction

   The Concise Binary Object Representation (CBOR [RFC8949]) is a data
   format whose design goals include the possibility of extremely small
   code size, fairly small message size, and extensibility without the
   need for version negotiation.

   In programming, there is often a need to define types that are
   composed of enumerated alternatives.  While CBOR has no problem
   representing types that are unions of other types, this may not make
   visible which of the enumerated alternatives was chosen, in
   particular if multiple alternatives overlap in their CBOR
   representations.  In other words, CBOR has no direct support for
   discriminated unions.

   In CBOR, one point of extensibility is the definition of CBOR tags.
   In protocol development, it is possible to register different tags
   for each alternative, but this would be difficult to automate in the
   course of using CBOR for normal program development, it might use up
   registration resources and tag numbers, and would create an unwelcome
   threshold for using CBOR in these activities.

   Instead, the alternatives could simply be numbered by a program
   compiler.  The present document defines tags for such a use in
   discriminated unions, i.e., where there is no intention to register
   application-specific tags for each of the branches in the union.

   Each of the tags specified in this document associates an unsigned
   number with the enclosed data item, with the intention that this
   number identifies one of a set of enumerated alternatives that could
   have been chosen at this position in the CBOR data item.

   For example data representing the result of some action might be
   either a failure with some failure detail, or a success with some
   result.  In this example there are two cases, the failure case and
   the success case, and they can be enumerated as 0 and 1.

   In general the number of alternatives, and what data is expected in
   each alternative case, are entirely application dependent.

   The tags defined in this specification allow the encoding of any
   number of alternatives, but provide compact encoding for the common
   cases of low numbers of alternatives:

   Alternatives 0..6 can be encoded with two additional bytes:

   *  Tag number 185..191 (1+1 encoding)

   *  tag content: the alternative

   Alternatives 7..127 can be encoded with three additional bytes:

   *  Tag number 1927..2047 (1+2 encoding)

   *  tag content: the alternative

   Alternatives 128+ can be encoded with 5-12 additional bytes:

   *  Tag number 184 (1+1 encoding)

   *  tag content: array (1+0 encoding), with the two elements:

      -  alternative number ("uint", 1+1 to 1+8 encoding) and

      -  data item: the alternative

   (The third representation can also be used for alternatives 0 to 127;
   see below.)

2.  Semantics

   Abstractly speaking, the value to be represented by these tags
   consists of a case number and a case body.  The case number is an
   unsigned integer that indicates which case out of the set of
   alternatives is used.  The case body is any CBOR data value.

   In a setting where the application uses a schema (formally or
   informally), then there will be an appropriate sub-schema for each
   case in the set of alternatives.  The representation of the case body
   should comply with the schema corresponding to the case number used.

   To continue the example above about representing failure or success,
   suppose that the failure detail consists of an integer code and a
   string, and suppose that the successful result is a byte string.  A
   failure value will use case 0 and the case body will be a list (CBOR
   array) containing an integer and a text string.  Alternatively, a
   success value will use case 1 and the body will be a single CBOR byte
   string.

   Decoders that enforce a schema must check the case number is within
   the range of cases allowed, and that the case body follows the schema
   for the supplied case number.  Generic decoders should allow any case
   number and any CBOR data value for the case body.

3.  Deterministically Encoded CBOR

   The tag 184 encoding overlaps with the more compact special encodings
   for 0..6 and 7..127.

   For applications that need deterministically encoded CBOR
   (Section 4.2 of [RFC8949]) the following convention must be used:
   alternatives in the range 0..127 must be encoded using the special
   compact encoding, and must not use the tag 184 encoding.  This
   follows the general deterministic CBOR encoding convention of using
   the most compact form.

      |     Issue:  Alternatively, tag 184 could encode the alternative
      |        number minus 128.  This would get some mileage out of the
      |        efficient encoding of unsigned integers 0..23 for the
      |        alternative numbers 128 to 151; these cases would be
      |        represented in 4 additional bytes.  More importantly, it
      |        would also get rid of the deterministic encoding
      |        considerations.  (I'm not suggesting encoding the
      |        alternative number minus 152, which would use the
      |        efficiency of both the negative and unsigned one-byte
      |        integers, or, worse, some zigzag encoding...)

4.  Rationale

   CBOR has direct support for _combinations_ of multiple values but not
   for _alternatives_, i.e. one of identified multiple values.
   Combinations are expressed in CBOR using lists (arrays) or maps.

   Most programming languages have a notion of data consisting of
   combinations of data values, often called records or objects.  Many
   programming languages also have a notion of data consisting of
   multiple alternative data values.  For example C has unions (the
   alternative in use is not identified, though), and other languages
   have "tagged" or "discriminated" unions (where it is always clear
   which alternative is in use).

   Crucially for this specification, the set of alternatives must be
   closed and ordered.  This allows encoding using a natural number to
   distinguish each case.

   Note that this does _not_ correspond to the notion in some
   programming languages of classes and sub-classes since in that
   context the set of alternatives is open and unordered.  Alternatives
   of this kind can be supported by other means, such as tag 27
   "Serialised language-independent object with type name and
   constructor arguments" [IANA.cbor-tags].

   In functional programming languages, the primary way of forming new
   data types is to enumerate a set of alternatives (each of which may
   be a record).  Such forms of data are also supported in hybrid
   functional languages or languages with functional features.

   Thus in some applications, it is very common to have data making use
   of alternatives, and it is worth finding a compact encoding, at least
   for the common cases.  Just as most records are small, most
   alternatives are also small.

   In this specification we allocate 7 values in the 1+1-byte part of
   the available tag encoding space for alternatives 0..6 which are by
   far the most common.  We allocate a range of 121 values in the
   1+2-bytes tag encoding space.  To cover the general case we allocate
   another 1+1-byte value for a representation using a pair consisting
   of an unsigned integer and the case body.

5.  Examples

   To elaborate on the example from the introduction, we have a "result"
   that is a failure or success, where:

   *  the failure detail consists of an integer code and a string;

   *  the successful result is a byte string;

   This corresponds to the following schema, in CDDL [RFC8610] notation:

   result = 185([int, text])
            186(bytes)

   Example values:

   *  "185([3, "the printer is on fire"])"

   *  "186(h'ff00')"

   As a second example, here is one based on a data type defined within
   the Haskell programming language, representing a simple expression
   tree.

   -- A data type representing simple arithmetic expressions:
   data Expr = Lit Int -- integer literal
             | Add Expr Expr -- addition
             | Sub Expr Expr -- subtraction
             | Neg Expr -- unary negation
             | Mul Expr Expr -- multiplication
             | Div Expr Expr -- integer division

   In CDDL notation, and using the tags in this specification, such data
   could be encoded using this schema:

   ; A data type representing simple arithmetic expressions

   expr = 185(int) ; integer literal
        / 186([expr, expr]) ; addition
        / 187([expr, expr]) ; subtraction
        / 188(expr) ; unary negation
        / 189([expr, expr]) ; multiplication
        / 190([expr, expr]) ; integer division

6.  IANA Considerations

   IANA is requested to allocate the following tag numbers in the CBOR
   tags registry [IANA.cbor-tags]:

     +============+======================+==============+===========+
     |        Tag | Data Item            | Semantics    | Reference |
     +============+======================+==============+===========+
     |        184 | array of one         | numbered     | [RFCthis] |
     |            | unsigned integer and | alternative  |           |
     |            | one item of any type | (numbered by |           |
     |            |                      | the uint)    |           |
     +------------+----------------------+--------------+-----------+
     |   185..191 | any                  | numbered     | [RFCthis] |
     |            |                      | alternative  |           |
     |            |                      | 0..6         |           |
     +------------+----------------------+--------------+-----------+
     | 1927..2047 | any                  | numbered     | [RFCthis] |
     |            |                      | alternative  |           |
     |            |                      | 7..127       |           |
     +------------+----------------------+--------------+-----------+

                      Table 1: Tags to be registered

7.  Security Considerations

   TBD

8.  References

8.1.  Normative References

   [IANA.cbor-tags]
              IANA, "Concise Binary Object Representation (CBOR) Tags",
              <http://www.iana.org/assignments/cbor-tags>.

   [RFC8949]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", STD 94, RFC 8949,
              DOI 10.17487/RFC8949, December 2020,
              <https://www.rfc-editor.org/info/rfc8949>.

8.2.  Informative References

   [RFC8610]  Birkholz, H., Vigano, C., and C. Bormann, "Concise Data
              Definition Language (CDDL): A Notational Convention to
              Express Concise Binary Object Representation (CBOR) and
              JSON Data Structures", RFC 8610, DOI 10.17487/RFC8610,
              June 2019, <https://www.rfc-editor.org/info/rfc8610>.

Authors' Addresses

   Duncan Coutts

   Email: duncan@well-typed.com


   Michael Peyton Jones

   Email: me@michaelpj.com


   Carsten Bormann (editor)
   Universität Bremen TZI
   Postfach 330440
   D-28359 Bremen
   Germany

   Phone: +49-421-218-63921
   Email: cabo@tzi.org
